//*****************************************************************************
/*!
	Copyright 2013 Autodesk, Inc.  All rights reserved.
	Use of this software is subject to the terms of the Autodesk license agreement
	provided at the time of installation or download, or which otherwise accompanies
	this software in either electronic or hard copy form.
*/
//*

// Abc import/export Plug-in
// Initial code generated by Softimage SDK Wizard
// Executed Thu May 23 10:56:50 UTC+0800 2013 by nguyenh
// 
// Tip: You need to compile the generated code before you can load the plug-in.
// After you compile the plug-in, you can load it by clicking Update All in the Plugin Manager.

#include "AbcXsiExporter.h"
#include "AbcXsiImporter.h"
#include <xsi_application.h>
#include <xsi_argument.h>
#include <xsi_command.h>
#include <xsi_context.h>
#include <xsi_pluginregistrar.h>
#include <xsi_project.h>
#include <xsi_status.h>
#include <xsi_menu.h>
#include <xsi_menuitem.h>
#include <xsi_ppgeventcontext.h>
#include <xsi_ppglayout.h>
#include <xsi_ppgitem.h>
#include <xsi_model.h>
#include <xsi_property.h>
#include <xsi_selection.h>
#include <xsi_comapihandler.h>
#include <xsi_utils.h>

using namespace XSI; 

static CString gOldImportPath; 
static CString gOldExportPath;

void AddDefaultAttributesToString( XSI::CString& io_cstr, const XSI::CString& in_cstrDefaultAttrs );

SICALLBACK XSILoadPlugin( PluginRegistrar& in_reg )
{
	in_reg.PutAuthor(L"Softimage");
	in_reg.PutName(L"Abc Import/Export Plug-in");
	in_reg.PutVersion(1,0);

	// Register the commands for Import and Export
	in_reg.RegisterCommand(L"AbcExport",L"AbcExport");
	in_reg.RegisterCommand(L"AbcImport",L"AbcImport");
	in_reg.RegisterCommand(L"AbcVer",L"AbcVer");

	// Register the properties for Import and Export
	in_reg.RegisterProperty( L"ImportAbcOptions" );
	in_reg.RegisterProperty( L"ExportAbcOptions" );

	// Below commands are accessed through the main menu by selecting the sub menu of File->Alembic. 
	// They equivalent to the AbcExport and AbcImport command, except that they will inspect options PPG and 
	// the browser dialog to specify the file name which will require users' confirmation.
	in_reg.RegisterCommand(L"OnAbcImportMenu",L"OnAbcImportMenu");
	in_reg.RegisterCommand(L"OnAbcExportMenu",L"OnAbcExportMenu");

	// Register the event to drag and drop abc file int Softimage
	in_reg.RegisterEvent(L"DragDropAbcFile", siOnDragAndDrop2);

	//RegistrationInsertionPoint - do not remove this line

	return CStatus::OK;
}

SICALLBACK XSIUnloadPlugin( const PluginRegistrar& in_reg )
{
	CString strPluginName;
	strPluginName = in_reg.GetName();
	Application().LogMessage(strPluginName + L" has been unloaded.",siVerboseMsg);
	return CStatus::OK;
}

SICALLBACK AbcExport_Init( CRef& in_ctxt )
{
	Context ctxt( in_ctxt );
	Command oCmd;
	oCmd = ctxt.GetSource();
	oCmd.PutDescription(L"");
	oCmd.EnableReturnValue(true);

	ArgumentArray oArgs;
	oArgs = oCmd.GetArguments();
	oArgs.Add(L"FilePathName", L"");
	oArgs.Add("StartFrame", 1);
	oArgs.Add("EndFrame", 100);
	oArgs.AddWithHandler("InputObjs", siArgHandlerCollection );
	oArgs.Add("IncludeParentHier", false);
	oArgs.Add(L"Storage", L"Ogawa");
	oArgs.Add(L"AttributesPointcloud", L"");
	oArgs.Add(L"AttributesPolymesh", L"");
	oArgs.Add(L"AttributesOtherPrim", L"");
	return CStatus::OK;
}

SICALLBACK AbcExport_Execute( CRef& in_ctxt )
{
	Context ctxt( in_ctxt );
	CValueArray l_XSIArgs = ctxt.GetAttribute(L"Arguments");
	CString l_csFileName = l_XSIArgs[0];
	LONG l_lStart = l_XSIArgs[1];
	LONG l_lEnd = l_XSIArgs[2];
	CRefArray l_inputObjs;
	l_inputObjs.Set( ( XSI::CValueArray& )( l_XSIArgs[3] ) );
	bool l_bIncludeParentHier = l_XSIArgs[4];
	CString l_csStorage = l_XSIArgs[5];
	CString l_csUserAttrsPointcloud = l_XSIArgs[6];
	CString l_csUserAttrsPolymesh = l_XSIArgs[7];
	CString l_csUserAttrsOtherPrim = l_XSIArgs[8];

	Application l_app;
	l_app.LogMessage(L"AbcExport_Execute called",siVerboseMsg);

	EAbcArchiveType l_eArchiveType = EArchiveType_Any;
	if ( l_csStorage.IsEqualNoCase( L"HDF5" ) )
		l_eArchiveType = EArchiveType_HDF5;
	else if ( l_csStorage.IsEqualNoCase( L"Ogawa" ) )
		l_eArchiveType = EArchiveType_Ogawa;
	else
		return CStatus::InvalidArgument;
	
	CStatus status;
	{
		Project l_prj = l_app.GetActiveProject();

		// The PlayControl property set is stored with scene data under the project
		CRefArray l_proplist = l_prj.GetProperties();
		Property l_playctrl( l_proplist.GetItem(L"Play Control") );

		if ( l_lStart < (LONG)l_playctrl.GetParameterValue( L"In") || 
			l_lEnd > (LONG)l_playctrl.GetParameterValue( L"Out" )  ||
			l_lStart > l_lEnd )
			return CStatus::InvalidArgument;
	{
		std::auto_ptr<AbcXsiExporter> l_pExporter( new AbcXsiExporter( l_csFileName, l_bIncludeParentHier, l_eArchiveType ) );
		l_pExporter->SetUserSpecifiedAttributes( l_csUserAttrsPolymesh, l_csUserAttrsPointcloud, l_csUserAttrsOtherPrim );
		status = l_pExporter->ExportObjects( l_inputObjs, l_lStart, l_lEnd );

		AttributeNameSet unexportedAttrs;
		l_pExporter->GetUnexportedAttributes( unexportedAttrs );
		for ( AttributeNameSet::ConstIterator it = unexportedAttrs.Begin(); it != unexportedAttrs.End(); ++it )
		{
			l_app.LogMessage( XSI::CUtils::Translate( L"Attribute not exported", L"ABCIMPORTEXPORT" ) + L": " + *it, siWarningMsg );
		}
	}
	}

	// Return a value by setting this attribute:
	ctxt.PutAttribute( L"ReturnValue", status==CStatus::OK );

	// Return CStatus::Fail if you want to raise a script error
	return status;
}

SICALLBACK AbcImport_Init( CRef& in_ctxt )
{
	Context ctxt( in_ctxt );
	Command oCmd;
	oCmd = ctxt.GetSource();
	oCmd.PutDescription(L"");
	oCmd.EnableReturnValue(true);

	ArgumentArray oArgs;
	oArgs = oCmd.GetArguments();
	oArgs.Add(L"FilePathName", L"");
	oArgs.Add(L"ImportAnimation", true);
	oArgs.Add("StartTime", -1.0);
	oArgs.Add("EndTime", -1.0);
	oArgs.Add("PadShapeClips", true );
	oArgs.Add("FitTimeRange", (int)ETimeRange_Expand );
	oArgs.Add("AnimationImportMode", (int)EImport_CacheOnFile );
	oArgs.Add("Parent", siArgHandlerSingleObj);
	oArgs.Add("CreateModel", false );
	oArgs.Add("CreateICETreeMode", (int)EImport_CreateICETreePerObj );
	return CStatus::OK;
}

SICALLBACK AbcImport_Execute( CRef& in_ctxt )
{
	Context ctxt( in_ctxt );
	CValueArray l_XSIArgs = ctxt.GetAttribute(L"Arguments");
	Application app;
	CString l_csFileName = l_XSIArgs[0];
	bool   l_bImportAnim = l_XSIArgs[1];
	double l_dStart = l_XSIArgs[2];
	double l_dEnd = l_XSIArgs[3];
	bool l_bPadShapeClips = l_XSIArgs[4];
	int l_iTimeRange = l_XSIArgs[5];
	int l_iAnimationImportMode = l_XSIArgs[6];
	X3DObject l_objParent( l_XSIArgs[7] );
	bool l_bCreateRootModel = l_XSIArgs[8];
	int l_iCreateICETreeMode = l_XSIArgs[9];

	if( !l_objParent.IsValid() )
	{
		Selection selList = app.GetSelection();
		if( selList.GetCount() > 0 && selList.GetItem( 0).IsA( siX3DObjectID ) )
			l_objParent = selList.GetItem( 0 ); // By default, pass the selected object as the parent.
		else
			l_objParent = app.GetActiveSceneRoot();
	}
	if ( l_iTimeRange < 0 || l_iTimeRange >= ETimeRange_Max )
	{
		app.LogMessage(L"Invalid FitTimeRange argument",siErrorMsg);
		return CStatus::Fail;
	}
	if ( l_iAnimationImportMode < 0 || l_iAnimationImportMode >= EImport_Max )
	{
		app.LogMessage(L"Invalid AnimationImportMode argument",siErrorMsg);
		return CStatus::Fail;
	}
	app.LogMessage(L"AbcImport_Execute called",siVerboseMsg);

	std::auto_ptr<AbcXsiImporter> l_pImporter( new AbcXsiImporter() );
	CStatus status = CStatus::Fail;
	if ( l_pImporter->SetFilename( l_csFileName ) == CStatus::OK &&
		 l_pImporter->SetTimeParams( l_bImportAnim, l_dStart, l_dEnd, (ETimeRangeFitting)l_iTimeRange ) == CStatus::OK &&
		 l_pImporter->SetAnimationImportMode( (EAnimationImportMode)l_iAnimationImportMode ) == CStatus::OK )
	{
		l_pImporter->SetPadShapeClips( l_bPadShapeClips );
		l_pImporter->SetCreateNewRootModel( l_bCreateRootModel );
		l_pImporter->SetRootParent( l_objParent );
		l_pImporter->SetCreateICETreeMode( (EImportICETreeMode)l_iCreateICETreeMode );
		status = l_pImporter->ImportObjects();
	}
	// Return a value by setting this attribute:
	ctxt.PutAttribute( L"ReturnValue", status==CStatus::OK );

	// Return CStatus::Fail if you want to raise a script error
	return CStatus::OK;
}

SICALLBACK AbcVer_Init( CRef& in_ctxt )
{
	Context ctxt( in_ctxt );
	Command oCmd;
	oCmd = ctxt.GetSource();
	oCmd.PutDescription(L"");
	oCmd.EnableReturnValue(false);

	return CStatus::OK;
}

SICALLBACK AbcVer_Execute( CRef& in_ctxt )
{
	AbcXsiIO l_AbcIO;
	if ( l_AbcIO.GetFrameworkPtr() )
	{
		CString l_csMsg = L"Using Alembic Framework ";
		l_csMsg += l_AbcIO.GetFrameworkPtr()->GetFrameworkVersionString();
		l_csMsg += L" with ";
		l_csMsg += l_AbcIO.GetFrameworkPtr()->GetAlembicVersionString();
		Application().LogMessage( l_csMsg, siInfoMsg );
	}
	return CStatus::OK;
}

SICALLBACK OnAbcImportMenu_Init( CRef& in_ctxt )
{
	Context ctxt( in_ctxt );
	Command oCmd;
	oCmd = ctxt.GetSource();
	oCmd.PutDescription(L"Prompt to set options and import an Alembic file");
	oCmd.EnableReturnValue(false);
	oCmd.SetFlag( siNoLogging, true );
	oCmd.SetFlag( siSupportsKeyAssignment, true );
	oCmd.SetFlag( siCannotBeUsedInBatch, true );

	ArgumentArray oArgs;
	oArgs = oCmd.GetArguments();
	oArgs.Add(L"FilePathName", L"");
	return CStatus::OK;
}

SICALLBACK OnAbcImportMenu_Execute( CRef& in_ctxt )
{
	Context ctxt( in_ctxt );
	Application app;
	
	// Inspect the ImportAbcOptions, to set the options for importer.
	Model rootModel = app.GetActiveSceneRoot();
	Property optionsProp;
	rootModel.GetPropertyFromName( L"ImportAbcOptions", optionsProp );	
	// Create new one if the property doesn't exist yet.
	if( !optionsProp.IsValid() )
		optionsProp = rootModel.AddProperty( L"ImportAbcOptions");
	
	CValueArray aInspectObjArgs(5);
	CValue retValue;
	aInspectObjArgs[0]= L"ImportAbcOptions";
	aInspectObjArgs[1]= CValue();
	aInspectObjArgs[2]= L"Alembic Import";
	aInspectObjArgs[3]= (LONG)siModal;
	aInspectObjArgs[4]= false;
	app.ExecuteCommand( L"InspectObj", aInspectObjArgs, retValue );
	
	if( retValue == true )
	{
		// Cancelled 
		return CStatus::Abort;
	}

	CValueArray args = ctxt.GetAttribute(L"Arguments");
	CString strFileFullName = args[0].GetAsText();
	// If the file was not specified, a file browser prompts the user to pick a file
	if( strFileFullName.IsEmpty() )
	{
		CComAPIHandler tk;
		tk.CreateInstance( L"XSI.UIToolkit" );
		CValue fb = tk.GetProperty( L"FileBrowser" );
		CComAPIHandler fileBrowser( fb );
		fileBrowser.PutProperty( L"Filter", CUtils::Translate( L"Alembic Files(*.abc)|*.abc||", L"ABCIMPORTEXPORT" ) );
		fileBrowser.PutProperty( L"DialogTitle", CUtils::Translate( L"Alembic Import", L"ABCIMPORTEXPORT" ) );

		if( gOldImportPath.IsEmpty() )
		{
			Project activeProj = app.GetActiveProject();
			gOldImportPath = activeProj.GetPath();
		}
		fileBrowser.PutProperty( L"InitialDirectory", gOldImportPath );
		fileBrowser.PutProperty( L"FileBaseName", L"" );
		CValue result;
		fileBrowser.Call( L"ShowOpen", result );
		result = fileBrowser.GetProperty( L"FilePathName" );
		strFileFullName = result.GetAsText();
		if ( strFileFullName.IsEmpty() )
		{
			return false;
		}
		// Cache the current directory as the initial location in next time
		gOldImportPath = fileBrowser.GetProperty( L"FilePath" );
	}

	CValueArray aImportArgs(10);
	aImportArgs[0] = strFileFullName;
	aImportArgs[8] = optionsProp.GetParameterValue( L"CreateModel");
	aImportArgs[9] = optionsProp.GetParameterValue( L"CreateICETreeMode" );
	app.ExecuteCommand( L"AbcImport", aImportArgs, retValue );

	return retValue? CStatus::OK : CStatus::Fail; 
}

SICALLBACK OnAbcExportMenu_Init( CRef& in_ctxt )
{
	Context ctxt( in_ctxt );
	Command oCmd;
	oCmd = ctxt.GetSource();
	oCmd.PutDescription(L"Prompt to set options and export an Alembic file");
	oCmd.EnableReturnValue(false);
	oCmd.SetFlag( siNoLogging, true );
	oCmd.SetFlag( siSupportsKeyAssignment, true );
	oCmd.SetFlag( siCannotBeUsedInBatch, true );

	return CStatus::OK;
}

SICALLBACK OnAbcExportMenu_Execute( CRef& in_ctxt )
{
	Application app;
	Model rootModel = app.GetActiveSceneRoot();
	Property optionsProp;
	rootModel.GetPropertyFromName( L"ExportAbcOptions", optionsProp );
	if( !optionsProp.IsValid() )
	{
		optionsProp = rootModel.AddProperty( L"ExportAbcOptions");
		SScenePlaybackSettings playbackSettings;
		optionsProp.PutParameterValue( L"StartFrame", playbackSettings.m_dFrameIn );
		optionsProp.PutParameterValue( L"EndFrame", playbackSettings.m_dFrameOut );
	}

	XSI::PPGLayout ppgLayout = optionsProp.GetPPGLayout();
	ppgLayout.SetViewSize( 559, 493 );

	CValueArray aInspectObjArgs(5);
	CValue retValue;
	aInspectObjArgs[0]= L"ExportAbcOptions";
	aInspectObjArgs[1]= XSI::CValue();
	aInspectObjArgs[2]= CUtils::Translate( L"Alembic Export", L"ABCIMPORTEXPORT" );
	aInspectObjArgs[3]= (LONG)XSI::siModal;
	aInspectObjArgs[4]= false;
	app.ExecuteCommand( L"InspectObj", aInspectObjArgs, retValue );

	if( retValue == true )
	{
		// Cancelled 
		return CStatus::Abort;
	}

	CComAPIHandler tk;
	tk.CreateInstance( L"XSI.UIToolkit" );
	CValue fb = tk.GetProperty( L"FileBrowser" );
	CComAPIHandler fileBrowser( fb );
	fileBrowser.PutProperty( L"Filter", CUtils::Translate( L"Alembic Files(*.abc)|*.abc||", L"ABCIMPORTEXPORT" ) );
	fileBrowser.PutProperty( L"DialogTitle", CUtils::Translate( L"Alembic Export", L"ABCIMPORTEXPORT" ) );
	
	if( gOldExportPath.IsEmpty() )
	{
		Project activeProj = app.GetActiveProject();
		gOldExportPath = activeProj.GetPath();
	}
	fileBrowser.PutProperty( L"InitialDirectory", gOldExportPath );
	fileBrowser.PutProperty( L"FileBaseName", L"" );
	CValue result;
	fileBrowser.Call( L"ShowSave", result );
	result = fileBrowser.GetProperty( L"FilePathName" );
	CString strFilePathName = result.GetAsText();
	if (strFilePathName.IsEmpty())
	{
		return false;
	}
	gOldExportPath = fileBrowser.GetProperty( L"FilePath" );

	CValueArray aExportArgs(9);
	aExportArgs[0] = strFilePathName;
	aExportArgs[1] = optionsProp.GetParameterValue( L"StartFrame" );
	aExportArgs[2] = optionsProp.GetParameterValue( L"EndFrame" );
	aExportArgs[3] = CValue( app.GetSelection().GetArray() );
	aExportArgs[4] = optionsProp.GetParameterValue( L"IncludeParentHier" );
	aExportArgs[5] = optionsProp.GetParameterValue( L"ArchiveFormat" );
	aExportArgs[6] = optionsProp.GetParameterValue( L"IncludeAttributesPointcloud" );
	aExportArgs[7] = optionsProp.GetParameterValue( L"IncludeAttributesPolymesh" );
	aExportArgs[8] = optionsProp.GetParameterValue( L"IncludeAttributesOtherPrim" );
	app.ExecuteCommand( L"AbcExport", aExportArgs, retValue );

	return retValue? CStatus::OK : CStatus::Fail;
}

SICALLBACK ImportAbcOptions_Define( const CRef& in_ctxt )
{
	// Here is where we add all the parameters to the 
	// Custom Property.  This will be called each time 
	// an new instance of the Custom Property is called.
	// It is not called when an persisted Custom Property is loaded.

	Context ctxt( in_ctxt );
	CustomProperty prop = ctxt.GetSource();

	XSI::Parameter param ;
	prop.AddParameter( L"CreateModel", CValue::siBool, siPersistable, L"Import under newly created Model", L"", CValue(false) ,param );
	prop.AddParameter( L"CreateICETreeMode", CValue::siInt4, siPersistable, L"Create ICETree per Object or single one to drive all Objects", L"", CValue((int)0), param );

	return CStatus::OK;
}

SICALLBACK ImportAbcOptions_DefineLayout( const CRef& in_ctxt )
{
	// XSI will call this to define the visual appearance of the CustomProperty
	// The layout is shared between all instances of the CustomProperty
	// and is cached.  You can force the code to re-execute by using the 
	// XSIUtils.Refresh feature.
	Context ctxt( in_ctxt );
	PPGLayout ppgLayout = ctxt.GetSource();
	ppgLayout.Clear();

	ppgLayout.AddGroup( L"Options" );		
		ppgLayout.AddItem( L"CreateModel" );		
		ppgLayout.AddGroup( L"ICE Trees for Importing" );
			CValueArray aModes( 4 );
			aModes[0] = L"Multiple - One per Object";
			aModes[1] = CValue(EImport_CreateICETreePerObj);
			aModes[2] = L"Single - One driving all Objects";
			aModes[3] = CValue(EImport_SingleICETree);
			PPGItem ppgItem;
			ppgItem = ppgLayout.AddEnumControl( L"CreateICETreeMode", aModes, "" );
			ppgItem.PutAttribute( siUINoLabel, CValue( true ) );
		ppgLayout.EndGroup();
	ppgLayout.EndGroup();

	ppgLayout.PutAttribute( siUIDictionary, CValue(L"ABCIMPORTEXPORT") );
	return CStatus::OK;
}

SICALLBACK ExportAbcOptions_Define( const CRef& in_ctxt )
{
	// Here is where we add all the parameters to the 
	// Custom Property.  This will be called each time 
	// an new instance of the Custom Property is called.
	// It is not called when an persisted Custom Property is loaded.

	Context ctxt( in_ctxt );
	CustomProperty prop = ctxt.GetSource();

	XSI::Parameter param ;
	prop.AddParameter( L"StartFrame", CValue::siDouble, siPersistable, L"Start Frame", L"", CValue((double)1.0), param );
	prop.AddParameter( L"EndFrame", CValue::siDouble, siPersistable, L"End Frame", L"", CValue((double)100.0), param );
	prop.AddParameter( L"IncludeParentHier", CValue::siBool, siPersistable, L"Include hierarchy up to Scene Root", L"", CValue( false ), param );
	prop.AddParameter( L"ArchiveFormat", CValue::siString, siPersistable, L"Archive Format", L"", L"Ogawa", param );
	

	XSI::CString l_csAttrs;
	AddDefaultAttributesToString( l_csAttrs, XSI::CString( AbcXsiExporter::DEFAULT_ATTRIBUTES_POINTCLOUD ) );
	prop.AddParameter( L"IncludeAttributesPointcloud", CValue::siString, siPersistable, L"Included ICE Attributes for Pointclouds", L"", l_csAttrs, param );

	l_csAttrs.Clear();
	AddDefaultAttributesToString( l_csAttrs, XSI::CString( AbcXsiExporter::DEFAULT_ATTRIBUTES_POLYMESH ) );
	prop.AddParameter( L"IncludeAttributesPolymesh", CValue::siString, siPersistable, L"Included ICE Attributes for Polymeshes", L"", l_csAttrs, param );

	prop.AddParameter( L"IncludeAttributesOtherPrim", CValue::siString, siPersistable, L"Included ICE Attributes for other primitives", L"", L"", param );
	return CStatus::OK;
}

SICALLBACK ExportAbcOptions_DefineLayout( const CRef& in_ctxt )
{
	// XSI will call this to define the visual appearance of the CustomProperty
	// The layout is shared between all instances of the CustomProperty
	// and is cached.  You can force the code to re-execute by using the 
	// XSIUtils.Refresh feature.
	Context ctxt( in_ctxt );
	PPGLayout ppgLayout = ctxt.GetSource();
	ppgLayout.Clear();

	ppgLayout.AddGroup( L"Time Range" );
		PPGItem ppgItem;
		ppgItem = ppgLayout.AddItem( L"StartFrame" );
		ppgItem.PutAttribute( siUIDecimals, 0 );
		ppgItem = ppgLayout.AddItem( L"EndFrame" );
		ppgItem.PutAttribute( siUIDecimals, 0 );
	ppgLayout.EndGroup();

	ppgLayout.AddGroup( L"Options");
		XSI::CValueArray formatsEnum(4);
		formatsEnum[0] = L"Ogawa";
		formatsEnum[1] = L"Ogawa";
		formatsEnum[2] = L"HDF5";
		formatsEnum[3] = L"HDF5";
		ppgLayout.AddEnumControl ( L"ArchiveFormat", formatsEnum );

		ppgLayout.AddItem( L"IncludeParentHier" );
	ppgLayout.EndGroup();

	ppgLayout.AddGroup( L"ICE Attributes for Pointclouds");
		ppgItem = ppgLayout.AddItem( L"IncludeAttributesPointcloud" );
		ppgItem.PutAttribute( XSI::siUINoLabel, true );
		ppgItem = ppgLayout.AddStaticText( L"PointPosition and ID will always be exported" );
		ppgLayout.AddRow();
		ppgLayout.AddGroup( "", false, 60 );
		ppgLayout.EndGroup();
		ppgLayout.AddButton( "ClearAttributesPointcloud", L"Delete All" );
		ppgLayout.AddButton( "AddDefaultAttributesPointcloud", L"Add Default Attributes" );
		ppgLayout.EndRow();
	ppgLayout.EndGroup();
	
	ppgLayout.AddGroup( L"ICE Attributes for Polygon Meshes");
		ppgItem = ppgLayout.AddItem( L"IncludeAttributesPolymesh" );
		ppgItem.PutAttribute( XSI::siUINoLabel , true );
		ppgLayout.AddRow();
		ppgLayout.AddGroup( "", false, 60 );
		ppgLayout.EndGroup();
		ppgLayout.AddButton( "ClearAttributesPolymesh", L"Delete All" );
		ppgLayout.AddButton( "AddDefaultAttributesPolymesh", L"Add Default Attributes" );
		ppgLayout.EndRow();
	ppgLayout.EndGroup();

	ppgLayout.AddGroup( L"ICE Attributes for other primitives");
		ppgItem = ppgLayout.AddItem( L"IncludeAttributesOtherPrim" );
		ppgItem.PutAttribute( XSI::siUINoLabel , true );
		ppgLayout.AddRow();
		ppgLayout.AddGroup( "", false, 60 );
		ppgLayout.EndGroup();
		ppgLayout.AddButton( "ClearAttributesOtherPrim", L"Delete All" );
		ppgLayout.EndRow();
	ppgLayout.EndGroup();
	ppgLayout.PutAttribute( siUIDictionary, CValue(L"ABCIMPORTEXPORT") );
	
	return CStatus::OK;
}

SICALLBACK ExportAbcOptions_PPGEvent( const CRef& in_ctxt )
{
	Application app ;
	PPGEventContext ctxt( in_ctxt ) ;

	PPGEventContext::PPGEvent eventID = ctxt.GetEventID();
	Property prop(ctxt.GetSource());

	if ( eventID == PPGEventContext::siButtonClicked )
	{
		// figure out which button was pressed
		CValue buttonPressed = ctxt.GetAttribute( L"Button" ) ;	
		CString buttonName = buttonPressed.GetAsText();
		
		if ( buttonName.IsEqualNoCase(L"AddDefaultAttributesPolymesh") )
		{
			XSI::Parameter param = prop.GetParameter( L"IncludeAttributesPolymesh" );
			XSI::CString defaultAttrs = AbcXsiExporter::DEFAULT_ATTRIBUTES_POLYMESH;

			XSI::CString curAttrs = param.GetValue();
			AddDefaultAttributesToString( curAttrs, defaultAttrs );
			param.PutValue( curAttrs );
		}
		else if ( buttonName.IsEqualNoCase(L"AddDefaultAttributesPointcloud") )
		{
			XSI::Parameter param = prop.GetParameter( L"IncludeAttributesPointcloud" );
			XSI::CString defaultAttrs = AbcXsiExporter::DEFAULT_ATTRIBUTES_POINTCLOUD;

			XSI::CString curAttrs = param.GetValue();
			AddDefaultAttributesToString( curAttrs, defaultAttrs );
			param.PutValue( curAttrs );
		}
		else if ( buttonName.IsEqualNoCase(L"ClearAttributesPolymesh") )
		{
			prop.PutParameterValue( L"IncludeAttributesPolymesh", XSI::CString() );
		}
		else if ( buttonName.IsEqualNoCase(L"ClearAttributesPointcloud") )
		{
			prop.PutParameterValue( L"IncludeAttributesPointcloud", XSI::CString() );
		}
		else if ( buttonName.IsEqualNoCase(L"ClearAttributesOtherPrim") )
		{
			prop.PutParameterValue( L"IncludeAttributesOtherPrim", XSI::CString() );
		}
	}
	return CStatus::OK;
}

SICALLBACK DragDropAbcFile_OnEvent( CRef& in_ctxt )
{
	Context ctxt( in_ctxt );
	CValue eAction = ctxt.GetAttribute( L"DragAndDropAction" );
	bool l_bSupported = false;
	if( eAction == siDragEnterAction || eAction == siDragOverAction || eAction == siDropAction )
	{
		bool l_bSupported = false;
		CValueArray aSourceObjs = ctxt.GetAttribute( L"DragSourceObjects" );
		for ( LONG i = 0; i < aSourceObjs.GetCount(); ++i )
		{
			CString fileFullName = aSourceObjs[i].GetAsText();
			if ( !fileFullName.IsEmpty() && ( fileFullName.ReverseFindString(L".abc") != UINT_MAX ) )
			{
				l_bSupported = true;
				if( eAction == siDropAction )
				{
					CValueArray aImportArgs(1);
					aImportArgs[0] = fileFullName;
					CValue retValue;
					Application().ExecuteCommand( L"OnAbcImportMenu", aImportArgs, retValue );
				}
			}
		}
		ctxt.PutAttribute( L"DragSourceSupported", l_bSupported? true : false );
		ctxt.PutAttribute( L"DragDropEffect", siDropEffectCopy );
	}

	//  Returns CStatus::False if you don't want to abort the event.
	return CStatus::False;
}

void AddDefaultAttributesToString( XSI::CString& io_cstr, const XSI::CString& in_cstrDefaultAttrs )
{
	AttributeNameSet l_curSet;

	CStringArray l_curArray;
	SplitAndTrim( l_curArray, io_cstr );

	l_curSet += l_curArray;

	if ( l_curSet.IsMatchAll() == false )
	{
		XSI::CStringArray l_defaultAttrs;
		SplitAndTrim( l_defaultAttrs, in_cstrDefaultAttrs );
		for (ULONG i=0; i<l_defaultAttrs.GetCount(); ++i)
		{
			if ( l_curSet.Insert( l_defaultAttrs[i] ) )
				l_curArray.Add( l_defaultAttrs[i] );
		}
	}

	if ( l_curArray.GetCount() > 0 )
	{
		io_cstr = l_curArray[0];
		for ( LONG i=1; i<l_curArray.GetCount(); ++i )
		{
			io_cstr += L", " + l_curArray[i];
		}
	}
}
